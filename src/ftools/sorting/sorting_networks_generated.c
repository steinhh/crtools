/* Sorting networks generated file */
/* This file is generated - do not edit manually */

/* Branchless swap macro using temporary variable */
#define SWAP(x, y)                      \
  do                                    \
  {                                     \
    double tmp = (x) < (y) ? (x) : (y); \
    (y) = (x) > (y) ? (x) : (y);        \
    (x) = tmp;                          \
  } while (0)

/* Sorting network for 3 elements - 3 comparators */
static inline void sort3(double *d)
{
  SWAP(d[0], d[1]);
  SWAP(d[0], d[2]);
  SWAP(d[1], d[2]);
}

/* Sorting network for 4 elements - 5 comparators */
static inline void sort4(double *d)
{
  SWAP(d[0], d[1]);
  SWAP(d[2], d[3]);
  SWAP(d[0], d[2]);
  SWAP(d[1], d[3]);
  SWAP(d[1], d[2]);
}

/* Sorting network for 9 elements - 25 comparators */
static inline void sort9(double *d)
{
  /* Stage 1: Sort columns */
  SWAP(d[0], d[1]);
  SWAP(d[3], d[4]);
  SWAP(d[6], d[7]);
  SWAP(d[1], d[2]);
  SWAP(d[4], d[5]);
  SWAP(d[7], d[8]);
  SWAP(d[0], d[1]);
  SWAP(d[3], d[4]);
  SWAP(d[6], d[7]);
  /* Stage 2: Sort rows */
  SWAP(d[0], d[3]);
  SWAP(d[3], d[6]);
  SWAP(d[0], d[3]);
  /* Stage 3: Merge */
  SWAP(d[1], d[4]);
  SWAP(d[4], d[7]);
  SWAP(d[1], d[4]);
  SWAP(d[2], d[5]);
  SWAP(d[5], d[8]);
  SWAP(d[2], d[5]);
  SWAP(d[1], d[3]);
  SWAP(d[5], d[7]);
  SWAP(d[2], d[6]);
  SWAP(d[4], d[6]);
  SWAP(d[2], d[4]);
  SWAP(d[2], d[3]);
  SWAP(d[5], d[6]);
}

// Auto-generated sorting networks
// Generated by generate_sorting_networks.py

/* Sorting network for 5 elements - 9 comparators */
static inline void sort5(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[3]);
  SWAP(d[1], d[4]);

  /* Stage 2 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[3]);

  /* Stage 3 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[4]);

  /* Stage 4 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[4]);

  /* Stage 5 */
  SWAP(d[2], d[3]);
}

/* Sorting network for 6 elements - 12 comparators */
static inline void sort6(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[5]);
  SWAP(d[1], d[3]);
  SWAP(d[2], d[4]);

  /* Stage 2 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[4]);

  /* Stage 3 */
  SWAP(d[0], d[3]);
  SWAP(d[2], d[5]);

  /* Stage 4 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);

  /* Stage 5 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[4]);
}

/* Sorting network for 7 elements - 16 comparators */
static inline void sort7(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[6]);
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);

  /* Stage 2 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[4]);
  SWAP(d[3], d[6]);

  /* Stage 3 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[5]);
  SWAP(d[3], d[4]);

  /* Stage 4 */
  SWAP(d[1], d[2]);
  SWAP(d[4], d[6]);

  /* Stage 5 */
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);

  /* Stage 6 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[4]);
  SWAP(d[5], d[6]);
}

/* Sorting network for 8 elements - 19 comparators */
static inline void sort8(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[3]);
  SWAP(d[4], d[6]);
  SWAP(d[5], d[7]);

  /* Stage 2 */
  SWAP(d[0], d[4]);
  SWAP(d[1], d[5]);
  SWAP(d[2], d[6]);
  SWAP(d[3], d[7]);

  /* Stage 3 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);

  /* Stage 4 */
  SWAP(d[2], d[4]);
  SWAP(d[3], d[5]);

  /* Stage 5 */
  SWAP(d[1], d[4]);
  SWAP(d[3], d[6]);

  /* Stage 6 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[4]);
  SWAP(d[5], d[6]);
}

/* Sorting network for 11 elements - 35 comparators */
static inline void sort11(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[9]);
  SWAP(d[1], d[6]);
  SWAP(d[2], d[4]);
  SWAP(d[3], d[7]);
  SWAP(d[5], d[8]);

  /* Stage 2 */
  SWAP(d[0], d[1]);
  SWAP(d[3], d[5]);
  SWAP(d[4], d[10]);
  SWAP(d[6], d[9]);
  SWAP(d[7], d[8]);

  /* Stage 3 */
  SWAP(d[1], d[3]);
  SWAP(d[2], d[5]);
  SWAP(d[4], d[7]);
  SWAP(d[8], d[10]);

  /* Stage 4 */
  SWAP(d[0], d[4]);
  SWAP(d[1], d[2]);
  SWAP(d[3], d[7]);
  SWAP(d[5], d[9]);
  SWAP(d[6], d[8]);

  /* Stage 5 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[6]);
  SWAP(d[4], d[5]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[10]);

  /* Stage 6 */
  SWAP(d[2], d[4]);
  SWAP(d[3], d[6]);
  SWAP(d[5], d[7]);
  SWAP(d[8], d[9]);

  /* Stage 7 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[4]);
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);

  /* Stage 8 */
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
}

/* Sorting network for 12 elements - 39 comparators */
static inline void sort12(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[8]);
  SWAP(d[1], d[7]);
  SWAP(d[2], d[6]);
  SWAP(d[3], d[11]);
  SWAP(d[4], d[10]);
  SWAP(d[5], d[9]);

  /* Stage 2 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[5]);
  SWAP(d[3], d[4]);
  SWAP(d[6], d[9]);
  SWAP(d[7], d[8]);
  SWAP(d[10], d[11]);

  /* Stage 3 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[6]);
  SWAP(d[5], d[10]);
  SWAP(d[9], d[11]);

  /* Stage 4 */
  SWAP(d[0], d[3]);
  SWAP(d[1], d[2]);
  SWAP(d[4], d[6]);
  SWAP(d[5], d[7]);
  SWAP(d[8], d[11]);
  SWAP(d[9], d[10]);

  /* Stage 5 */
  SWAP(d[1], d[4]);
  SWAP(d[3], d[5]);
  SWAP(d[6], d[8]);
  SWAP(d[7], d[10]);

  /* Stage 6 */
  SWAP(d[1], d[3]);
  SWAP(d[2], d[5]);
  SWAP(d[6], d[9]);
  SWAP(d[8], d[10]);

  /* Stage 7 */
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);

  /* Stage 8 */
  SWAP(d[4], d[6]);
  SWAP(d[5], d[7]);

  /* Stage 9 */
  SWAP(d[3], d[4]);
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);
}

/* Sorting network for 13 elements - 45 comparators */
static inline void sort13(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[12]);
  SWAP(d[1], d[10]);
  SWAP(d[2], d[9]);
  SWAP(d[3], d[7]);
  SWAP(d[5], d[11]);
  SWAP(d[6], d[8]);

  /* Stage 2 */
  SWAP(d[1], d[6]);
  SWAP(d[2], d[3]);
  SWAP(d[4], d[11]);
  SWAP(d[7], d[9]);
  SWAP(d[8], d[10]);

  /* Stage 3 */
  SWAP(d[0], d[4]);
  SWAP(d[1], d[2]);
  SWAP(d[3], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[10]);
  SWAP(d[11], d[12]);

  /* Stage 4 */
  SWAP(d[4], d[6]);
  SWAP(d[5], d[9]);
  SWAP(d[8], d[11]);
  SWAP(d[10], d[12]);

  /* Stage 5 */
  SWAP(d[0], d[5]);
  SWAP(d[3], d[8]);
  SWAP(d[4], d[7]);
  SWAP(d[6], d[11]);
  SWAP(d[9], d[10]);

  /* Stage 6 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[5]);
  SWAP(d[6], d[9]);
  SWAP(d[7], d[8]);
  SWAP(d[10], d[11]);

  /* Stage 7 */
  SWAP(d[1], d[3]);
  SWAP(d[2], d[4]);
  SWAP(d[5], d[6]);
  SWAP(d[9], d[10]);

  /* Stage 8 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[4]);
  SWAP(d[5], d[7]);
  SWAP(d[6], d[8]);

  /* Stage 9 */
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);

  /* Stage 10 */
  SWAP(d[3], d[4]);
  SWAP(d[5], d[6]);
}

/* Sorting network for 14 elements - 51 comparators */
static inline void sort14(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);

  /* Stage 2 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[3]);
  SWAP(d[4], d[8]);
  SWAP(d[5], d[9]);
  SWAP(d[10], d[12]);
  SWAP(d[11], d[13]);

  /* Stage 3 */
  SWAP(d[0], d[4]);
  SWAP(d[1], d[2]);
  SWAP(d[3], d[7]);
  SWAP(d[5], d[8]);
  SWAP(d[6], d[10]);
  SWAP(d[9], d[13]);
  SWAP(d[11], d[12]);

  /* Stage 4 */
  SWAP(d[0], d[6]);
  SWAP(d[1], d[5]);
  SWAP(d[3], d[9]);
  SWAP(d[4], d[10]);
  SWAP(d[7], d[13]);
  SWAP(d[8], d[12]);

  /* Stage 5 */
  SWAP(d[2], d[10]);
  SWAP(d[3], d[11]);
  SWAP(d[4], d[6]);
  SWAP(d[7], d[9]);

  /* Stage 6 */
  SWAP(d[1], d[3]);
  SWAP(d[2], d[8]);
  SWAP(d[5], d[11]);
  SWAP(d[6], d[7]);
  SWAP(d[10], d[12]);

  /* Stage 7 */
  SWAP(d[1], d[4]);
  SWAP(d[2], d[6]);
  SWAP(d[3], d[5]);
  SWAP(d[7], d[11]);
  SWAP(d[8], d[10]);
  SWAP(d[9], d[12]);

  /* Stage 8 */
  SWAP(d[2], d[4]);
  SWAP(d[3], d[6]);
  SWAP(d[5], d[8]);
  SWAP(d[7], d[10]);
  SWAP(d[9], d[11]);

  /* Stage 9 */
  SWAP(d[3], d[4]);
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[10]);

  /* Stage 10 */
  SWAP(d[6], d[7]);
}

/* Sorting network for 15 elements - 56 comparators */
static inline void sort15(double *d)
{
  /* Stage 1 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[10]);
  SWAP(d[4], d[14]);
  SWAP(d[5], d[8]);
  SWAP(d[6], d[13]);
  SWAP(d[7], d[12]);
  SWAP(d[9], d[11]);

  /* Stage 2 */
  SWAP(d[0], d[14]);
  SWAP(d[1], d[5]);
  SWAP(d[2], d[8]);
  SWAP(d[3], d[7]);
  SWAP(d[6], d[9]);
  SWAP(d[10], d[12]);
  SWAP(d[11], d[13]);

  /* Stage 3 */
  SWAP(d[0], d[7]);
  SWAP(d[1], d[6]);
  SWAP(d[2], d[9]);
  SWAP(d[4], d[10]);
  SWAP(d[5], d[11]);
  SWAP(d[8], d[13]);
  SWAP(d[12], d[14]);

  /* Stage 4 */
  SWAP(d[0], d[6]);
  SWAP(d[2], d[4]);
  SWAP(d[3], d[5]);
  SWAP(d[7], d[11]);
  SWAP(d[8], d[10]);
  SWAP(d[9], d[12]);
  SWAP(d[13], d[14]);

  /* Stage 5 */
  SWAP(d[0], d[3]);
  SWAP(d[1], d[2]);
  SWAP(d[4], d[7]);
  SWAP(d[5], d[9]);
  SWAP(d[6], d[8]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);

  /* Stage 6 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[3]);
  SWAP(d[4], d[6]);
  SWAP(d[7], d[9]);
  SWAP(d[10], d[12]);
  SWAP(d[11], d[13]);

  /* Stage 7 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[5]);
  SWAP(d[8], d[10]);
  SWAP(d[11], d[12]);

  /* Stage 8 */
  SWAP(d[3], d[4]);
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[10]);

  /* Stage 9 */
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[11]);

  /* Stage 10 */
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);
}

/* Sorting network for 16 elements - 60 comparators */
static inline void sort16(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[13]);
  SWAP(d[1], d[12]);
  SWAP(d[2], d[15]);
  SWAP(d[3], d[14]);
  SWAP(d[4], d[8]);
  SWAP(d[5], d[6]);
  SWAP(d[7], d[11]);
  SWAP(d[9], d[10]);

  /* Stage 2 */
  SWAP(d[0], d[5]);
  SWAP(d[1], d[7]);
  SWAP(d[2], d[9]);
  SWAP(d[3], d[4]);
  SWAP(d[6], d[13]);
  SWAP(d[8], d[14]);
  SWAP(d[10], d[15]);
  SWAP(d[11], d[12]);

  /* Stage 3 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[8]);
  SWAP(d[7], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);
  SWAP(d[14], d[15]);

  /* Stage 4 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[3]);
  SWAP(d[4], d[10]);
  SWAP(d[5], d[11]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[12], d[14]);
  SWAP(d[13], d[15]);

  /* Stage 5 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[12]);
  SWAP(d[4], d[6]);
  SWAP(d[5], d[7]);
  SWAP(d[8], d[10]);
  SWAP(d[9], d[11]);
  SWAP(d[13], d[14]);

  /* Stage 6 */
  SWAP(d[1], d[4]);
  SWAP(d[2], d[6]);
  SWAP(d[5], d[8]);
  SWAP(d[7], d[10]);
  SWAP(d[9], d[13]);
  SWAP(d[11], d[14]);

  /* Stage 7 */
  SWAP(d[2], d[4]);
  SWAP(d[3], d[6]);
  SWAP(d[9], d[12]);
  SWAP(d[11], d[13]);

  /* Stage 8 */
  SWAP(d[3], d[5]);
  SWAP(d[6], d[8]);
  SWAP(d[7], d[9]);
  SWAP(d[10], d[12]);

  /* Stage 9 */
  SWAP(d[3], d[4]);
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[10]);
  SWAP(d[11], d[12]);

  /* Stage 10 */
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
}

/* Sorting network for 17 elements - 71 comparators */
static inline void sort17(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[11]);
  SWAP(d[1], d[15]);
  SWAP(d[2], d[10]);
  SWAP(d[3], d[5]);
  SWAP(d[4], d[6]);
  SWAP(d[8], d[12]);
  SWAP(d[9], d[16]);
  SWAP(d[13], d[14]);

  /* Stage 2 */
  SWAP(d[0], d[6]);
  SWAP(d[1], d[13]);
  SWAP(d[2], d[8]);
  SWAP(d[4], d[14]);
  SWAP(d[5], d[15]);
  SWAP(d[7], d[11]);

  /* Stage 3 */
  SWAP(d[0], d[8]);
  SWAP(d[3], d[7]);
  SWAP(d[4], d[9]);
  SWAP(d[6], d[16]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[14]);

  /* Stage 4 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[4]);
  SWAP(d[5], d[6]);
  SWAP(d[7], d[13]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[12]);
  SWAP(d[11], d[14]);
  SWAP(d[15], d[16]);

  /* Stage 5 */
  SWAP(d[0], d[3]);
  SWAP(d[2], d[5]);
  SWAP(d[6], d[11]);
  SWAP(d[7], d[10]);
  SWAP(d[9], d[13]);
  SWAP(d[12], d[15]);
  SWAP(d[14], d[16]);

  /* Stage 6 */
  SWAP(d[0], d[1]);
  SWAP(d[3], d[4]);
  SWAP(d[5], d[10]);
  SWAP(d[6], d[9]);
  SWAP(d[7], d[8]);
  SWAP(d[11], d[15]);
  SWAP(d[13], d[14]);

  /* Stage 7 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[7]);
  SWAP(d[4], d[8]);
  SWAP(d[6], d[12]);
  SWAP(d[11], d[13]);
  SWAP(d[14], d[15]);

  /* Stage 8 */
  SWAP(d[1], d[3]);
  SWAP(d[2], d[7]);
  SWAP(d[4], d[5]);
  SWAP(d[9], d[11]);
  SWAP(d[10], d[12]);
  SWAP(d[13], d[14]);

  /* Stage 9 */
  SWAP(d[2], d[3]);
  SWAP(d[4], d[6]);
  SWAP(d[5], d[7]);
  SWAP(d[8], d[10]);

  /* Stage 10 */
  SWAP(d[3], d[4]);
  SWAP(d[6], d[8]);
  SWAP(d[7], d[9]);
  SWAP(d[10], d[12]);

  /* Stage 11 */
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[10]);
  SWAP(d[11], d[12]);

  /* Stage 12 */
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);
}

/* Sorting network for 18 elements - 77 comparators */
static inline void sort18(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);
  SWAP(d[14], d[15]);
  SWAP(d[16], d[17]);

  /* Stage 2 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[3]);
  SWAP(d[4], d[12]);
  SWAP(d[5], d[13]);
  SWAP(d[6], d[8]);
  SWAP(d[9], d[11]);
  SWAP(d[14], d[16]);
  SWAP(d[15], d[17]);

  /* Stage 3 */
  SWAP(d[0], d[14]);
  SWAP(d[1], d[16]);
  SWAP(d[2], d[15]);
  SWAP(d[3], d[17]);

  /* Stage 4 */
  SWAP(d[0], d[6]);
  SWAP(d[1], d[10]);
  SWAP(d[2], d[9]);
  SWAP(d[7], d[16]);
  SWAP(d[8], d[15]);
  SWAP(d[11], d[17]);

  /* Stage 5 */
  SWAP(d[1], d[4]);
  SWAP(d[3], d[9]);
  SWAP(d[5], d[7]);
  SWAP(d[8], d[14]);
  SWAP(d[10], d[12]);
  SWAP(d[13], d[16]);

  /* Stage 6 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[5]);
  SWAP(d[3], d[13]);
  SWAP(d[4], d[14]);
  SWAP(d[7], d[9]);
  SWAP(d[8], d[10]);
  SWAP(d[12], d[15]);
  SWAP(d[16], d[17]);

  /* Stage 7 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[5]);
  SWAP(d[4], d[6]);
  SWAP(d[11], d[13]);
  SWAP(d[12], d[14]);
  SWAP(d[15], d[16]);

  /* Stage 8 */
  SWAP(d[4], d[8]);
  SWAP(d[5], d[12]);
  SWAP(d[6], d[10]);
  SWAP(d[7], d[11]);
  SWAP(d[9], d[13]);

  /* Stage 9 */
  SWAP(d[1], d[4]);
  SWAP(d[2], d[8]);
  SWAP(d[3], d[6]);
  SWAP(d[5], d[7]);
  SWAP(d[9], d[15]);
  SWAP(d[10], d[12]);
  SWAP(d[11], d[14]);
  SWAP(d[13], d[16]);

  /* Stage 10 */
  SWAP(d[2], d[4]);
  SWAP(d[5], d[8]);
  SWAP(d[6], d[10]);
  SWAP(d[7], d[11]);
  SWAP(d[9], d[12]);
  SWAP(d[13], d[15]);

  /* Stage 11 */
  SWAP(d[3], d[5]);
  SWAP(d[6], d[8]);
  SWAP(d[7], d[10]);
  SWAP(d[9], d[11]);
  SWAP(d[12], d[14]);

  /* Stage 12 */
  SWAP(d[3], d[4]);
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[10]);
  SWAP(d[11], d[12]);
  SWAP(d[13], d[14]);
}

/* Sorting network for 19 elements - 85 comparators */
static inline void sort19(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[12]);
  SWAP(d[1], d[4]);
  SWAP(d[2], d[8]);
  SWAP(d[3], d[5]);
  SWAP(d[6], d[17]);
  SWAP(d[7], d[11]);
  SWAP(d[9], d[14]);
  SWAP(d[10], d[13]);
  SWAP(d[15], d[16]);

  /* Stage 2 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[7]);
  SWAP(d[3], d[6]);
  SWAP(d[4], d[11]);
  SWAP(d[5], d[17]);
  SWAP(d[8], d[12]);
  SWAP(d[10], d[15]);
  SWAP(d[13], d[16]);
  SWAP(d[14], d[18]);

  /* Stage 3 */
  SWAP(d[3], d[10]);
  SWAP(d[4], d[14]);
  SWAP(d[5], d[15]);
  SWAP(d[6], d[13]);
  SWAP(d[7], d[9]);
  SWAP(d[11], d[17]);
  SWAP(d[16], d[18]);

  /* Stage 4 */
  SWAP(d[0], d[7]);
  SWAP(d[1], d[10]);
  SWAP(d[4], d[6]);
  SWAP(d[9], d[15]);
  SWAP(d[11], d[16]);
  SWAP(d[12], d[17]);
  SWAP(d[13], d[14]);

  /* Stage 5 */
  SWAP(d[0], d[3]);
  SWAP(d[2], d[6]);
  SWAP(d[5], d[7]);
  SWAP(d[8], d[11]);
  SWAP(d[12], d[16]);

  /* Stage 6 */
  SWAP(d[1], d[8]);
  SWAP(d[2], d[9]);
  SWAP(d[3], d[4]);
  SWAP(d[6], d[15]);
  SWAP(d[7], d[13]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[18]);

  /* Stage 7 */
  SWAP(d[1], d[3]);
  SWAP(d[2], d[5]);
  SWAP(d[6], d[9]);
  SWAP(d[7], d[12]);
  SWAP(d[8], d[10]);
  SWAP(d[11], d[14]);
  SWAP(d[17], d[18]);

  /* Stage 8 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[3]);
  SWAP(d[4], d[8]);
  SWAP(d[6], d[10]);
  SWAP(d[9], d[12]);
  SWAP(d[14], d[15]);
  SWAP(d[16], d[17]);

  /* Stage 9 */
  SWAP(d[1], d[2]);
  SWAP(d[5], d[8]);
  SWAP(d[6], d[7]);
  SWAP(d[9], d[11]);
  SWAP(d[10], d[13]);
  SWAP(d[14], d[16]);
  SWAP(d[15], d[17]);

  /* Stage 10 */
  SWAP(d[3], d[6]);
  SWAP(d[4], d[5]);
  SWAP(d[7], d[9]);
  SWAP(d[8], d[10]);
  SWAP(d[11], d[12]);
  SWAP(d[13], d[14]);
  SWAP(d[15], d[16]);

  /* Stage 11 */
  SWAP(d[3], d[4]);
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[10]);
  SWAP(d[11], d[13]);
  SWAP(d[12], d[14]);

  /* Stage 12 */
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);
  SWAP(d[14], d[15]);
}

/* Sorting network for 20 elements - 91 comparators */
static inline void sort20(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[3]);
  SWAP(d[1], d[7]);
  SWAP(d[2], d[5]);
  SWAP(d[4], d[8]);
  SWAP(d[6], d[9]);
  SWAP(d[10], d[13]);
  SWAP(d[11], d[15]);
  SWAP(d[12], d[18]);
  SWAP(d[14], d[17]);
  SWAP(d[16], d[19]);

  /* Stage 2 */
  SWAP(d[0], d[14]);
  SWAP(d[1], d[11]);
  SWAP(d[2], d[16]);
  SWAP(d[3], d[17]);
  SWAP(d[4], d[12]);
  SWAP(d[5], d[19]);
  SWAP(d[6], d[10]);
  SWAP(d[7], d[15]);
  SWAP(d[8], d[18]);
  SWAP(d[9], d[13]);

  /* Stage 3 */
  SWAP(d[0], d[4]);
  SWAP(d[1], d[2]);
  SWAP(d[3], d[8]);
  SWAP(d[5], d[7]);
  SWAP(d[11], d[16]);
  SWAP(d[12], d[14]);
  SWAP(d[15], d[19]);
  SWAP(d[17], d[18]);

  /* Stage 4 */
  SWAP(d[1], d[6]);
  SWAP(d[2], d[12]);
  SWAP(d[3], d[5]);
  SWAP(d[4], d[11]);
  SWAP(d[7], d[17]);
  SWAP(d[8], d[15]);
  SWAP(d[13], d[18]);
  SWAP(d[14], d[16]);

  /* Stage 5 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[6]);
  SWAP(d[7], d[10]);
  SWAP(d[9], d[12]);
  SWAP(d[13], d[17]);
  SWAP(d[18], d[19]);

  /* Stage 6 */
  SWAP(d[1], d[6]);
  SWAP(d[5], d[9]);
  SWAP(d[7], d[11]);
  SWAP(d[8], d[12]);
  SWAP(d[10], d[14]);
  SWAP(d[13], d[18]);

  /* Stage 7 */
  SWAP(d[3], d[5]);
  SWAP(d[4], d[7]);
  SWAP(d[8], d[10]);
  SWAP(d[9], d[11]);
  SWAP(d[12], d[15]);
  SWAP(d[14], d[16]);

  /* Stage 8 */
  SWAP(d[1], d[3]);
  SWAP(d[2], d[4]);
  SWAP(d[5], d[7]);
  SWAP(d[6], d[10]);
  SWAP(d[9], d[13]);
  SWAP(d[12], d[14]);
  SWAP(d[15], d[17]);
  SWAP(d[16], d[18]);

  /* Stage 9 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[4]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);
  SWAP(d[15], d[16]);
  SWAP(d[17], d[18]);

  /* Stage 10 */
  SWAP(d[2], d[3]);
  SWAP(d[4], d[6]);
  SWAP(d[5], d[8]);
  SWAP(d[7], d[9]);
  SWAP(d[10], d[12]);
  SWAP(d[11], d[14]);
  SWAP(d[13], d[15]);
  SWAP(d[16], d[17]);

  /* Stage 11 */
  SWAP(d[4], d[5]);
  SWAP(d[6], d[8]);
  SWAP(d[7], d[10]);
  SWAP(d[9], d[12]);
  SWAP(d[11], d[13]);
  SWAP(d[14], d[15]);

  /* Stage 12 */
  SWAP(d[3], d[4]);
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[10]);
  SWAP(d[11], d[12]);
  SWAP(d[13], d[14]);
  SWAP(d[15], d[16]);
}

/* Sorting network for 21 elements - 99 comparators */
static inline void sort21(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);
  SWAP(d[14], d[15]);
  SWAP(d[16], d[17]);
  SWAP(d[18], d[19]);

  /* Stage 2 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[3]);
  SWAP(d[4], d[6]);
  SWAP(d[5], d[7]);
  SWAP(d[8], d[10]);
  SWAP(d[9], d[11]);
  SWAP(d[12], d[14]);
  SWAP(d[13], d[15]);
  SWAP(d[16], d[18]);
  SWAP(d[17], d[19]);

  /* Stage 3 */
  SWAP(d[0], d[8]);
  SWAP(d[1], d[9]);
  SWAP(d[2], d[10]);
  SWAP(d[3], d[11]);
  SWAP(d[4], d[12]);
  SWAP(d[5], d[13]);
  SWAP(d[6], d[14]);
  SWAP(d[7], d[15]);

  /* Stage 4 */
  SWAP(d[0], d[4]);
  SWAP(d[1], d[5]);
  SWAP(d[3], d[7]);
  SWAP(d[6], d[20]);
  SWAP(d[8], d[12]);
  SWAP(d[9], d[13]);
  SWAP(d[10], d[14]);
  SWAP(d[15], d[19]);

  /* Stage 5 */
  SWAP(d[2], d[6]);
  SWAP(d[3], d[18]);
  SWAP(d[7], d[20]);

  /* Stage 6 */
  SWAP(d[2], d[16]);
  SWAP(d[3], d[6]);
  SWAP(d[5], d[18]);
  SWAP(d[7], d[17]);
  SWAP(d[11], d[20]);

  /* Stage 7 */
  SWAP(d[0], d[2]);
  SWAP(d[3], d[8]);
  SWAP(d[6], d[12]);
  SWAP(d[7], d[10]);
  SWAP(d[9], d[16]);
  SWAP(d[11], d[15]);
  SWAP(d[13], d[17]);
  SWAP(d[14], d[18]);
  SWAP(d[19], d[20]);

  /* Stage 8 */
  SWAP(d[1], d[7]);
  SWAP(d[2], d[3]);
  SWAP(d[4], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[13], d[16]);
  SWAP(d[15], d[18]);
  SWAP(d[17], d[19]);

  /* Stage 9 */
  SWAP(d[1], d[4]);
  SWAP(d[5], d[10]);
  SWAP(d[6], d[13]);
  SWAP(d[7], d[8]);
  SWAP(d[11], d[14]);
  SWAP(d[12], d[16]);
  SWAP(d[15], d[17]);
  SWAP(d[18], d[19]);

  /* Stage 10 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[4]);
  SWAP(d[5], d[6]);
  SWAP(d[10], d[12]);
  SWAP(d[11], d[13]);
  SWAP(d[14], d[16]);
  SWAP(d[17], d[18]);

  /* Stage 11 */
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);
  SWAP(d[14], d[15]);
  SWAP(d[16], d[17]);

  /* Stage 12 */
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[15], d[16]);

  /* Stage 13 */
  SWAP(d[4], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[12]);
  SWAP(d[13], d[15]);

  /* Stage 14 */
  SWAP(d[3], d[4]);
  SWAP(d[5], d[7]);
  SWAP(d[8], d[10]);
  SWAP(d[9], d[11]);
  SWAP(d[12], d[14]);

  /* Stage 15 */
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[10]);
  SWAP(d[11], d[12]);
  SWAP(d[13], d[14]);
}

/* Sorting network for 22 elements - 106 comparators */
static inline void sort22(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);
  SWAP(d[14], d[15]);
  SWAP(d[16], d[17]);
  SWAP(d[18], d[19]);
  SWAP(d[20], d[21]);

  /* Stage 2 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[3]);
  SWAP(d[4], d[6]);
  SWAP(d[5], d[7]);
  SWAP(d[8], d[12]);
  SWAP(d[9], d[13]);
  SWAP(d[14], d[16]);
  SWAP(d[15], d[17]);
  SWAP(d[18], d[20]);
  SWAP(d[19], d[21]);

  /* Stage 3 */
  SWAP(d[0], d[4]);
  SWAP(d[1], d[5]);
  SWAP(d[2], d[6]);
  SWAP(d[3], d[7]);
  SWAP(d[8], d[10]);
  SWAP(d[9], d[12]);
  SWAP(d[11], d[13]);
  SWAP(d[14], d[18]);
  SWAP(d[15], d[19]);
  SWAP(d[16], d[20]);
  SWAP(d[17], d[21]);

  /* Stage 4 */
  SWAP(d[0], d[14]);
  SWAP(d[1], d[15]);
  SWAP(d[2], d[18]);
  SWAP(d[3], d[19]);
  SWAP(d[4], d[16]);
  SWAP(d[5], d[17]);
  SWAP(d[6], d[20]);
  SWAP(d[7], d[21]);
  SWAP(d[9], d[11]);
  SWAP(d[10], d[12]);

  /* Stage 5 */
  SWAP(d[2], d[8]);
  SWAP(d[3], d[11]);
  SWAP(d[6], d[9]);
  SWAP(d[10], d[18]);
  SWAP(d[12], d[15]);
  SWAP(d[13], d[19]);

  /* Stage 6 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[10]);
  SWAP(d[3], d[16]);
  SWAP(d[5], d[18]);
  SWAP(d[6], d[14]);
  SWAP(d[7], d[15]);
  SWAP(d[8], d[12]);
  SWAP(d[9], d[13]);
  SWAP(d[11], d[20]);
  SWAP(d[19], d[21]);

  /* Stage 7 */
  SWAP(d[2], d[6]);
  SWAP(d[3], d[10]);
  SWAP(d[4], d[8]);
  SWAP(d[5], d[12]);
  SWAP(d[9], d[16]);
  SWAP(d[11], d[18]);
  SWAP(d[13], d[17]);
  SWAP(d[15], d[19]);

  /* Stage 8 */
  SWAP(d[1], d[4]);
  SWAP(d[7], d[13]);
  SWAP(d[8], d[14]);
  SWAP(d[9], d[12]);
  SWAP(d[17], d[20]);

  /* Stage 9 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[8]);
  SWAP(d[4], d[6]);
  SWAP(d[7], d[11]);
  SWAP(d[10], d[14]);
  SWAP(d[13], d[18]);
  SWAP(d[15], d[17]);
  SWAP(d[19], d[20]);

  /* Stage 10 */
  SWAP(d[2], d[4]);
  SWAP(d[5], d[10]);
  SWAP(d[7], d[9]);
  SWAP(d[11], d[16]);
  SWAP(d[12], d[14]);
  SWAP(d[17], d[19]);

  /* Stage 11 */
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[11]);
  SWAP(d[10], d[12]);
  SWAP(d[13], d[14]);
  SWAP(d[15], d[16]);

  /* Stage 12 */
  SWAP(d[3], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[10]);
  SWAP(d[9], d[12]);
  SWAP(d[11], d[13]);
  SWAP(d[14], d[15]);
  SWAP(d[16], d[18]);

  /* Stage 13 */
  SWAP(d[3], d[4]);
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[10]);
  SWAP(d[11], d[12]);
  SWAP(d[13], d[14]);
  SWAP(d[15], d[16]);
  SWAP(d[17], d[18]);
}

/* Sorting network for 23 elements - 114 comparators */
static inline void sort23(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);
  SWAP(d[14], d[15]);
  SWAP(d[16], d[17]);
  SWAP(d[18], d[19]);
  SWAP(d[20], d[21]);

  /* Stage 2 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[3]);
  SWAP(d[4], d[6]);
  SWAP(d[5], d[7]);
  SWAP(d[8], d[10]);
  SWAP(d[9], d[11]);
  SWAP(d[12], d[14]);
  SWAP(d[13], d[15]);
  SWAP(d[16], d[18]);
  SWAP(d[17], d[19]);
  SWAP(d[21], d[22]);

  /* Stage 3 */
  SWAP(d[0], d[4]);
  SWAP(d[1], d[5]);
  SWAP(d[2], d[6]);
  SWAP(d[3], d[7]);
  SWAP(d[8], d[12]);
  SWAP(d[9], d[13]);
  SWAP(d[10], d[14]);
  SWAP(d[11], d[15]);
  SWAP(d[17], d[21]);
  SWAP(d[18], d[20]);
  SWAP(d[19], d[22]);

  /* Stage 4 */
  SWAP(d[0], d[8]);
  SWAP(d[1], d[9]);
  SWAP(d[2], d[10]);
  SWAP(d[3], d[11]);
  SWAP(d[4], d[12]);
  SWAP(d[5], d[13]);
  SWAP(d[6], d[14]);
  SWAP(d[7], d[15]);

  /* Stage 5 */
  SWAP(d[1], d[2]);
  SWAP(d[5], d[18]);
  SWAP(d[7], d[19]);
  SWAP(d[9], d[16]);
  SWAP(d[10], d[21]);
  SWAP(d[12], d[20]);
  SWAP(d[15], d[22]);

  /* Stage 6 */
  SWAP(d[5], d[9]);
  SWAP(d[6], d[7]);
  SWAP(d[10], d[18]);
  SWAP(d[11], d[21]);
  SWAP(d[12], d[17]);
  SWAP(d[13], d[20]);
  SWAP(d[14], d[15]);

  /* Stage 7 */
  SWAP(d[3], d[17]);
  SWAP(d[6], d[16]);
  SWAP(d[7], d[14]);
  SWAP(d[8], d[12]);
  SWAP(d[15], d[19]);
  SWAP(d[20], d[21]);

  /* Stage 8 */
  SWAP(d[3], d[4]);
  SWAP(d[5], d[8]);
  SWAP(d[6], d[10]);
  SWAP(d[9], d[12]);
  SWAP(d[13], d[16]);
  SWAP(d[14], d[15]);
  SWAP(d[17], d[18]);
  SWAP(d[19], d[21]);

  /* Stage 9 */
  SWAP(d[0], d[5]);
  SWAP(d[1], d[8]);
  SWAP(d[2], d[12]);
  SWAP(d[3], d[9]);
  SWAP(d[4], d[10]);
  SWAP(d[7], d[13]);
  SWAP(d[11], d[17]);
  SWAP(d[14], d[16]);
  SWAP(d[18], d[20]);

  /* Stage 10 */
  SWAP(d[2], d[6]);
  SWAP(d[3], d[5]);
  SWAP(d[4], d[8]);
  SWAP(d[7], d[11]);
  SWAP(d[10], d[12]);
  SWAP(d[13], d[18]);
  SWAP(d[14], d[17]);
  SWAP(d[15], d[20]);

  /* Stage 11 */
  SWAP(d[1], d[3]);
  SWAP(d[2], d[5]);
  SWAP(d[6], d[9]);
  SWAP(d[7], d[10]);
  SWAP(d[11], d[13]);
  SWAP(d[12], d[14]);
  SWAP(d[15], d[18]);
  SWAP(d[16], d[17]);
  SWAP(d[19], d[20]);

  /* Stage 12 */
  SWAP(d[2], d[3]);
  SWAP(d[4], d[6]);
  SWAP(d[8], d[9]);
  SWAP(d[11], d[12]);
  SWAP(d[13], d[14]);
  SWAP(d[15], d[16]);
  SWAP(d[17], d[19]);

  /* Stage 13 */
  SWAP(d[3], d[4]);
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[10]);
  SWAP(d[12], d[13]);
  SWAP(d[14], d[15]);
  SWAP(d[17], d[18]);

  /* Stage 14 */
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[16], d[17]);
}

/* Sorting network for 24 elements - 120 comparators */
static inline void sort24(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[20]);
  SWAP(d[1], d[12]);
  SWAP(d[2], d[16]);
  SWAP(d[3], d[23]);
  SWAP(d[4], d[6]);
  SWAP(d[5], d[10]);
  SWAP(d[7], d[21]);
  SWAP(d[8], d[14]);
  SWAP(d[9], d[15]);
  SWAP(d[11], d[22]);
  SWAP(d[13], d[18]);
  SWAP(d[17], d[19]);

  /* Stage 2 */
  SWAP(d[0], d[3]);
  SWAP(d[1], d[11]);
  SWAP(d[2], d[7]);
  SWAP(d[4], d[17]);
  SWAP(d[5], d[13]);
  SWAP(d[6], d[19]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[18]);
  SWAP(d[12], d[22]);
  SWAP(d[14], d[15]);
  SWAP(d[16], d[21]);
  SWAP(d[20], d[23]);

  /* Stage 3 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[4]);
  SWAP(d[3], d[12]);
  SWAP(d[5], d[8]);
  SWAP(d[6], d[9]);
  SWAP(d[7], d[10]);
  SWAP(d[11], d[20]);
  SWAP(d[13], d[16]);
  SWAP(d[14], d[17]);
  SWAP(d[15], d[18]);
  SWAP(d[19], d[21]);
  SWAP(d[22], d[23]);

  /* Stage 4 */
  SWAP(d[2], d[5]);
  SWAP(d[4], d[8]);
  SWAP(d[6], d[11]);
  SWAP(d[7], d[14]);
  SWAP(d[9], d[16]);
  SWAP(d[12], d[17]);
  SWAP(d[15], d[19]);
  SWAP(d[18], d[21]);

  /* Stage 5 */
  SWAP(d[1], d[8]);
  SWAP(d[3], d[14]);
  SWAP(d[4], d[7]);
  SWAP(d[9], d[20]);
  SWAP(d[10], d[12]);
  SWAP(d[11], d[13]);
  SWAP(d[15], d[22]);
  SWAP(d[16], d[19]);

  /* Stage 6 */
  SWAP(d[0], d[7]);
  SWAP(d[1], d[5]);
  SWAP(d[3], d[4]);
  SWAP(d[6], d[11]);
  SWAP(d[8], d[15]);
  SWAP(d[9], d[14]);
  SWAP(d[10], d[13]);
  SWAP(d[12], d[17]);
  SWAP(d[16], d[23]);
  SWAP(d[18], d[22]);
  SWAP(d[19], d[20]);

  /* Stage 7 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[6]);
  SWAP(d[4], d[7]);
  SWAP(d[5], d[9]);
  SWAP(d[8], d[10]);
  SWAP(d[13], d[15]);
  SWAP(d[14], d[18]);
  SWAP(d[16], d[19]);
  SWAP(d[17], d[22]);
  SWAP(d[21], d[23]);

  /* Stage 8 */
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[8]);
  SWAP(d[7], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);
  SWAP(d[14], d[16]);
  SWAP(d[15], d[17]);
  SWAP(d[18], d[19]);
  SWAP(d[20], d[21]);

  /* Stage 9 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[6]);
  SWAP(d[4], d[10]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[11]);
  SWAP(d[12], d[14]);
  SWAP(d[13], d[19]);
  SWAP(d[15], d[16]);
  SWAP(d[17], d[20]);
  SWAP(d[21], d[22]);

  /* Stage 10 */
  SWAP(d[2], d[3]);
  SWAP(d[5], d[10]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[13], d[18]);
  SWAP(d[14], d[15]);
  SWAP(d[16], d[17]);
  SWAP(d[20], d[21]);

  /* Stage 11 */
  SWAP(d[3], d[4]);
  SWAP(d[5], d[7]);
  SWAP(d[10], d[12]);
  SWAP(d[11], d[13]);
  SWAP(d[16], d[18]);
  SWAP(d[19], d[20]);

  /* Stage 12 */
  SWAP(d[4], d[6]);
  SWAP(d[8], d[10]);
  SWAP(d[9], d[12]);
  SWAP(d[11], d[14]);
  SWAP(d[13], d[15]);
  SWAP(d[17], d[19]);

  /* Stage 13 */
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[10]);
  SWAP(d[11], d[12]);
  SWAP(d[13], d[14]);
  SWAP(d[15], d[16]);
  SWAP(d[17], d[18]);
}

/* Sorting network for 25 elements - 130 comparators */
static inline void sort25b(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);
  SWAP(d[14], d[15]);
  SWAP(d[16], d[17]);
  SWAP(d[18], d[19]);
  SWAP(d[20], d[21]);
  SWAP(d[22], d[23]);

  /* Stage 2 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[3]);
  SWAP(d[4], d[6]);
  SWAP(d[5], d[7]);
  SWAP(d[8], d[10]);
  SWAP(d[9], d[11]);
  SWAP(d[12], d[14]);
  SWAP(d[13], d[15]);
  SWAP(d[16], d[18]);
  SWAP(d[17], d[19]);
  SWAP(d[21], d[22]);
  SWAP(d[23], d[24]);

  /* Stage 3 */
  SWAP(d[0], d[4]);
  SWAP(d[1], d[5]);
  SWAP(d[2], d[6]);
  SWAP(d[3], d[7]);
  SWAP(d[8], d[12]);
  SWAP(d[9], d[13]);
  SWAP(d[10], d[14]);
  SWAP(d[11], d[15]);
  SWAP(d[18], d[21]);
  SWAP(d[20], d[23]);
  SWAP(d[22], d[24]);

  /* Stage 4 */
  SWAP(d[0], d[8]);
  SWAP(d[1], d[9]);
  SWAP(d[2], d[10]);
  SWAP(d[3], d[11]);
  SWAP(d[4], d[12]);
  SWAP(d[5], d[13]);
  SWAP(d[6], d[14]);
  SWAP(d[7], d[15]);
  SWAP(d[16], d[20]);
  SWAP(d[17], d[22]);
  SWAP(d[19], d[24]);
  SWAP(d[21], d[23]);

  /* Stage 5 */
  SWAP(d[1], d[18]);
  SWAP(d[3], d[21]);
  SWAP(d[5], d[23]);
  SWAP(d[6], d[19]);
  SWAP(d[11], d[14]);
  SWAP(d[15], d[24]);

  /* Stage 6 */
  SWAP(d[1], d[16]);
  SWAP(d[3], d[17]);
  SWAP(d[6], d[9]);
  SWAP(d[7], d[11]);
  SWAP(d[13], d[19]);
  SWAP(d[14], d[23]);

  /* Stage 7 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[16]);
  SWAP(d[3], d[8]);
  SWAP(d[7], d[20]);
  SWAP(d[10], d[13]);
  SWAP(d[11], d[22]);
  SWAP(d[15], d[23]);

  /* Stage 8 */
  SWAP(d[1], d[2]);
  SWAP(d[5], d[10]);
  SWAP(d[7], d[18]);
  SWAP(d[11], d[21]);
  SWAP(d[15], d[20]);
  SWAP(d[19], d[22]);

  /* Stage 9 */
  SWAP(d[4], d[7]);
  SWAP(d[5], d[6]);
  SWAP(d[9], d[18]);
  SWAP(d[10], d[17]);
  SWAP(d[11], d[12]);
  SWAP(d[13], d[21]);
  SWAP(d[14], d[15]);
  SWAP(d[19], d[20]);
  SWAP(d[22], d[23]);

  /* Stage 10 */
  SWAP(d[3], d[4]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[10]);
  SWAP(d[11], d[16]);
  SWAP(d[12], d[17]);
  SWAP(d[13], d[18]);
  SWAP(d[19], d[21]);
  SWAP(d[20], d[22]);

  /* Stage 11 */
  SWAP(d[1], d[3]);
  SWAP(d[2], d[4]);
  SWAP(d[5], d[11]);
  SWAP(d[6], d[16]);
  SWAP(d[7], d[9]);
  SWAP(d[8], d[10]);
  SWAP(d[12], d[13]);
  SWAP(d[14], d[19]);
  SWAP(d[15], d[18]);

  /* Stage 12 */
  SWAP(d[2], d[3]);
  SWAP(d[5], d[7]);
  SWAP(d[6], d[9]);
  SWAP(d[8], d[11]);
  SWAP(d[10], d[16]);
  SWAP(d[12], d[14]);
  SWAP(d[15], d[17]);

  /* Stage 13 */
  SWAP(d[3], d[5]);
  SWAP(d[4], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[11]);
  SWAP(d[10], d[12]);
  SWAP(d[13], d[14]);
  SWAP(d[15], d[16]);
  SWAP(d[17], d[18]);

  /* Stage 14 */
  SWAP(d[4], d[7]);
  SWAP(d[6], d[8]);
  SWAP(d[9], d[10]);
  SWAP(d[11], d[12]);
  SWAP(d[13], d[15]);
  SWAP(d[14], d[16]);
  SWAP(d[17], d[19]);
  SWAP(d[18], d[21]);

  /* Stage 15 */
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);
  SWAP(d[14], d[15]);
  SWAP(d[16], d[17]);
  SWAP(d[18], d[19]);
  SWAP(d[20], d[21]);
}

/* Sorting network for 25 elements (5x5 window) - Hybrid approach */
static inline void sort25(double *d)
{
  /* Hybrid approach using sort9 for pre-sorting, then insertion sort.
   * This is faster than a pure sorting network for 25 elements (which would need ~120+ comparators).
   * The sort9 networks create a partially sorted structure that makes insertion sort very efficient.
   */

  /* Sort 4 groups of 9 elements using the sort9 network */
  sort9(&d[0]); /* First 3x3 block */
  sort9(&d[9]); /* Second 3x3 block (shifted by 9) */

  /* Now sort the remaining 7 elements mixed with the pre-sorted blocks */
  sort9(&d[16]); /* Elements 16-24 */

  /* Complete the sort using insertion sort on the mostly-sorted array */
  for (int i = 1; i < 25; i++)
  {
    double key = d[i];
    int j = i - 1;
    while (j >= 0 && d[j] > key)
    {
      d[j + 1] = d[j];
      j--;
    }
    d[j + 1] = key;
  }
}

/* Sorting network for 26 elements - 115 comparators */
static inline void sort26(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);
  SWAP(d[14], d[15]);
  SWAP(d[16], d[17]);
  SWAP(d[18], d[19]);
  SWAP(d[20], d[21]);
  SWAP(d[22], d[23]);
  SWAP(d[24], d[25]);

  /* Stage 2 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[3]);
  SWAP(d[4], d[6]);
  SWAP(d[5], d[7]);
  SWAP(d[8], d[10]);
  SWAP(d[9], d[11]);
  SWAP(d[14], d[16]);
  SWAP(d[15], d[17]);
  SWAP(d[18], d[20]);
  SWAP(d[19], d[21]);
  SWAP(d[22], d[24]);
  SWAP(d[23], d[25]);

  /* Stage 3 */
  SWAP(d[0], d[4]);
  SWAP(d[1], d[6]);
  SWAP(d[2], d[5]);
  SWAP(d[3], d[7]);
  SWAP(d[8], d[14]);
  SWAP(d[9], d[16]);
  SWAP(d[10], d[15]);
  SWAP(d[11], d[17]);
  SWAP(d[18], d[22]);
  SWAP(d[19], d[24]);
  SWAP(d[20], d[23]);
  SWAP(d[21], d[25]);

  /* Stage 4 */
  SWAP(d[0], d[18]);
  SWAP(d[1], d[19]);
  SWAP(d[2], d[20]);
  SWAP(d[3], d[21]);
  SWAP(d[4], d[22]);
  SWAP(d[5], d[23]);
  SWAP(d[6], d[24]);
  SWAP(d[7], d[25]);
  SWAP(d[9], d[12]);
  SWAP(d[13], d[16]);

  /* Stage 5 */
  SWAP(d[3], d[11]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[13]);
  SWAP(d[12], d[15]);
  SWAP(d[14], d[22]);
  SWAP(d[16], d[17]);

  /* Stage 6 */
  SWAP(d[0], d[8]);
  SWAP(d[1], d[9]);
  SWAP(d[2], d[14]);
  SWAP(d[6], d[12]);
  SWAP(d[7], d[15]);
  SWAP(d[10], d[18]);
  SWAP(d[11], d[23]);
  SWAP(d[13], d[19]);
  SWAP(d[16], d[24]);
  SWAP(d[17], d[25]);

  /* Stage 7 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[18]);
  SWAP(d[4], d[8]);
  SWAP(d[7], d[22]);
  SWAP(d[17], d[21]);
  SWAP(d[23], d[24]);

  /* Stage 8 */
  SWAP(d[3], d[14]);
  SWAP(d[4], d[10]);
  SWAP(d[5], d[18]);
  SWAP(d[7], d[20]);
  SWAP(d[8], d[13]);
  SWAP(d[11], d[22]);
  SWAP(d[12], d[17]);
  SWAP(d[15], d[21]);

  /* Stage 9 */
  SWAP(d[1], d[4]);
  SWAP(d[5], d[6]);
  SWAP(d[7], d[9]);
  SWAP(d[8], d[10]);
  SWAP(d[15], d[17]);
  SWAP(d[16], d[18]);
  SWAP(d[19], d[20]);
  SWAP(d[21], d[24]);

  /* Stage 10 */
  SWAP(d[2], d[5]);
  SWAP(d[3], d[10]);
  SWAP(d[6], d[14]);
  SWAP(d[9], d[13]);
  SWAP(d[11], d[19]);
  SWAP(d[12], d[16]);
  SWAP(d[15], d[22]);
  SWAP(d[20], d[23]);

  /* Stage 11 */
  SWAP(d[2], d[8]);
  SWAP(d[5], d[7]);
  SWAP(d[6], d[9]);
  SWAP(d[11], d[12]);
  SWAP(d[13], d[14]);
  SWAP(d[16], d[19]);
  SWAP(d[17], d[23]);
  SWAP(d[18], d[20]);

  /* Stage 12 */
  SWAP(d[2], d[4]);
  SWAP(d[3], d[5]);
  SWAP(d[6], d[11]);
  SWAP(d[7], d[10]);
  SWAP(d[9], d[16]);
  SWAP(d[12], d[13]);
  SWAP(d[14], d[19]);
  SWAP(d[15], d[18]);
  SWAP(d[20], d[22]);
  SWAP(d[21], d[23]);

  /* Stage 13 */
  SWAP(d[3], d[4]);
  SWAP(d[5], d[8]);
  SWAP(d[6], d[7]);
  SWAP(d[9], d[11]);
  SWAP(d[10], d[12]);
  SWAP(d[13], d[15]);
  SWAP(d[14], d[16]);
  SWAP(d[17], d[20]);
  SWAP(d[18], d[19]);
  SWAP(d[21], d[22]);

  /* Stage 14 */
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[10]);
  SWAP(d[11], d[12]);
  SWAP(d[13], d[14]);
  SWAP(d[15], d[16]);
  SWAP(d[17], d[18]);
  SWAP(d[19], d[20]);

  /* Stage 15 */
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);
  SWAP(d[14], d[15]);
  SWAP(d[16], d[17]);
  SWAP(d[18], d[19]);
  SWAP(d[20], d[21]);
}

/* Sorting network for 27 elements (3x3x3 window) - Hybrid approach */
static inline void sort27(double *d)
{
  /* Hybrid approach for 27 elements.
   * A pure sorting network for 27 elements is complex (~170-200 comparators).
   * This hybrid uses proven sorting networks for initial structure,
   * then completes with insertion sort.
   * Performance: The pre-sorting makes insertion sort very efficient (mostly sorted input).
   * Correctness: Guaranteed by insertion sort.
   */

  /* Stage 1: Sort 9 groups of 3 elements each using sort3 network (27 comparators) */
  sort3(&d[0]);
  sort3(&d[3]);
  sort3(&d[6]);
  sort3(&d[9]);
  sort3(&d[12]);
  sort3(&d[15]);
  sort3(&d[18]);
  sort3(&d[21]);
  sort3(&d[24]);

  /* Stage 2: Sort 3 groups of 9 elements each using sort9 network */
  sort9(&d[0]);
  sort9(&d[9]);
  sort9(&d[18]);

  /* Stage 3: Complete the sort using insertion sort on the mostly-sorted array */
  for (int i = 1; i < 27; i++)
  {
    double key = d[i];
    int j = i - 1;
    while (j >= 0 && d[j] > key)
    {
      d[j + 1] = d[j];
      j--;
    }
    d[j + 1] = key;
  }
}

/* Complete sorting network for 27 elements - 114 comparators */
static inline void sort27b(double *d)
{
  /* Stage 1 */
  SWAP(d[0], d[1]);
  SWAP(d[2], d[3]);
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[14]);
  SWAP(d[15], d[16]);
  SWAP(d[17], d[18]);
  SWAP(d[19], d[20]);
  SWAP(d[21], d[22]);
  SWAP(d[23], d[24]);
  SWAP(d[25], d[26]);

  /* Stage 2 */
  SWAP(d[0], d[2]);
  SWAP(d[1], d[3]);
  SWAP(d[4], d[6]);
  SWAP(d[5], d[7]);
  SWAP(d[8], d[10]);
  SWAP(d[9], d[11]);
  SWAP(d[12], d[13]);
  SWAP(d[15], d[17]);
  SWAP(d[16], d[18]);
  SWAP(d[19], d[21]);
  SWAP(d[20], d[22]);
  SWAP(d[23], d[25]);
  SWAP(d[24], d[26]);

  /* Stage 3 */
  SWAP(d[0], d[23]);
  SWAP(d[1], d[24]);
  SWAP(d[2], d[25]);
  SWAP(d[3], d[26]);
  SWAP(d[4], d[8]);
  SWAP(d[5], d[9]);
  SWAP(d[6], d[10]);
  SWAP(d[7], d[11]);
  SWAP(d[13], d[14]);
  SWAP(d[15], d[19]);
  SWAP(d[16], d[20]);
  SWAP(d[17], d[21]);
  SWAP(d[18], d[22]);

  /* Stage 4 */
  SWAP(d[0], d[4]);
  SWAP(d[1], d[6]);
  SWAP(d[2], d[19]);
  SWAP(d[3], d[20]);
  SWAP(d[5], d[13]);
  SWAP(d[9], d[21]);
  SWAP(d[11], d[14]);
  SWAP(d[12], d[16]);
  SWAP(d[17], d[23]);
  SWAP(d[18], d[24]);
  SWAP(d[22], d[26]);

  /* Stage 5 */
  SWAP(d[5], d[17]);
  SWAP(d[6], d[16]);
  SWAP(d[7], d[22]);
  SWAP(d[9], d[25]);
  SWAP(d[10], d[24]);
  SWAP(d[12], d[15]);
  SWAP(d[13], d[20]);
  SWAP(d[14], d[26]);

  /* Stage 6 */
  SWAP(d[1], d[12]);
  SWAP(d[4], d[15]);
  SWAP(d[7], d[23]);
  SWAP(d[10], d[19]);
  SWAP(d[11], d[16]);
  SWAP(d[13], d[18]);
  SWAP(d[20], d[24]);
  SWAP(d[22], d[25]);

  /* Stage 7 */
  SWAP(d[0], d[1]);
  SWAP(d[6], d[12]);
  SWAP(d[8], d[11]);
  SWAP(d[9], d[15]);
  SWAP(d[10], d[17]);
  SWAP(d[14], d[24]);
  SWAP(d[16], d[21]);
  SWAP(d[18], d[19]);

  /* Stage 8 */
  SWAP(d[1], d[4]);
  SWAP(d[2], d[8]);
  SWAP(d[3], d[11]);
  SWAP(d[12], d[15]);
  SWAP(d[14], d[20]);
  SWAP(d[16], d[22]);
  SWAP(d[21], d[25]);

  /* Stage 9 */
  SWAP(d[2], d[5]);
  SWAP(d[3], d[17]);
  SWAP(d[8], d[13]);
  SWAP(d[11], d[23]);
  SWAP(d[21], d[22]);
  SWAP(d[24], d[25]);

  /* Stage 10 */
  SWAP(d[1], d[2]);
  SWAP(d[3], d[10]);
  SWAP(d[5], d[6]);
  SWAP(d[7], d[13]);
  SWAP(d[11], d[15]);
  SWAP(d[14], d[21]);
  SWAP(d[18], d[23]);
  SWAP(d[20], d[22]);

  /* Stage 11 */
  SWAP(d[4], d[5]);
  SWAP(d[6], d[9]);
  SWAP(d[7], d[8]);
  SWAP(d[13], d[17]);
  SWAP(d[14], d[16]);
  SWAP(d[19], d[23]);
  SWAP(d[22], d[24]);

  /* Stage 12 */
  SWAP(d[2], d[4]);
  SWAP(d[3], d[6]);
  SWAP(d[5], d[7]);
  SWAP(d[8], d[12]);
  SWAP(d[9], d[10]);
  SWAP(d[11], d[13]);
  SWAP(d[14], d[18]);
  SWAP(d[15], d[17]);
  SWAP(d[16], d[19]);
  SWAP(d[21], d[23]);

  /* Stage 13 */
  SWAP(d[3], d[5]);
  SWAP(d[6], d[8]);
  SWAP(d[7], d[9]);
  SWAP(d[10], d[12]);
  SWAP(d[11], d[14]);
  SWAP(d[13], d[16]);
  SWAP(d[15], d[18]);
  SWAP(d[17], d[19]);
  SWAP(d[20], d[21]);
  SWAP(d[22], d[23]);

  /* Stage 14 */
  SWAP(d[5], d[6]);
  SWAP(d[8], d[11]);
  SWAP(d[9], d[10]);
  SWAP(d[12], d[14]);
  SWAP(d[13], d[15]);
  SWAP(d[17], d[18]);
  SWAP(d[19], d[21]);

  /* Stage 15 */
  SWAP(d[4], d[5]);
  SWAP(d[6], d[7]);
  SWAP(d[8], d[9]);
  SWAP(d[10], d[11]);
  SWAP(d[12], d[13]);
  SWAP(d[14], d[15]);
  SWAP(d[16], d[17]);
  SWAP(d[18], d[20]);
  SWAP(d[21], d[22]);

  /* Stage 16 */
  SWAP(d[3], d[4]);
  SWAP(d[5], d[6]);
  SWAP(d[7], d[8]);
  SWAP(d[9], d[10]);
  SWAP(d[11], d[12]);
  SWAP(d[13], d[14]);
  SWAP(d[15], d[16]);
  SWAP(d[17], d[18]);
  SWAP(d[19], d[20]);
}

/* Hybrid sort124: Uses sort24 blocks + insertion sort for 124 elements */
static inline void sort124(double *d)
{
  /* Hybrid approach: sort 5 blocks of 24 elements + 4 remaining, then insertion sort
   * 124 = 5 * 24 + 4
   * Pre-sorting the larger blocks creates a partially sorted structure
   */

  /* Sort 5 blocks of 24 elements each using sort24 */
  sort24(&d[0]);  /* Elements 0-23 */
  sort24(&d[24]); /* Elements 24-47 */
  sort24(&d[48]); /* Elements 48-71 */
  sort24(&d[72]); /* Elements 72-95 */
  sort24(&d[96]); /* Elements 96-119 */
  /* Elements 120-123 (4 elements) left unsorted initially */

  /* Complete the sort using insertion sort on the partially-sorted array */
  for (int i = 1; i < 124; i++)
  {
    double key = d[i];
    int j = i - 1;
    while (j >= 0 && d[j] > key)
    {
      d[j + 1] = d[j];
      j--;
    }
    d[j + 1] = key;
  }
}

/* Hybrid sort125: Uses sort25 blocks + insertion sort for 125 elements */
static inline void sort125(double *d)
{
  /* Hybrid approach: sort 5 blocks of 25 elements, then insertion sort
   * 125 = 5 * 25, so we can use sort25b for pre-sorting
   * This creates a partially sorted structure that makes insertion sort efficient
   */

  /* Sort 5 blocks of 25 elements each using sort25b */
  sort25b(&d[0]);   /* Elements 0-24 */
  sort25b(&d[25]);  /* Elements 25-49 */
  sort25b(&d[50]);  /* Elements 50-74 */
  sort25b(&d[75]);  /* Elements 75-99 */
  sort25b(&d[100]); /* Elements 100-124 */

  /* Complete the sort using insertion sort on the partially-sorted array
   * The pre-sorted blocks reduce the number of comparisons needed
   */
  for (int i = 1; i < 125; i++)
  {
    double key = d[i];
    int j = i - 1;
    while (j >= 0 && d[j] > key)
    {
      d[j + 1] = d[j];
      j--;
    }
    d[j + 1] = key;
  }
}
